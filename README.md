Висновки та порівняння алгоритмів видачі решти. 

1.Жадібний алгоритм (find_coins_greedy)
Принцип роботи:Цей алгоритм є простим і інтуїтивно зрозумілим. Він завжди вибирає найбільшу можливу монету на кожному кроці, поки сума, яку потрібно видати, не стане нульовою.
Для нашого набору монет [50, 25, 10, 5, 2, 1] він дає оптимальний результат.Ефективність та продуктивність:Часова складність: O(k), де k — кількість номіналів монет.
Продуктивність: Дуже висока. Час виконання практично не залежить від величини суми, оскільки алгоритм просто ітерує по фіксованому набору монет. 
Жадібний алгоритм є надзвичайно швидким, що робить його ідеальним для касових апаратів, де швидкість обробки транзакцій критична.
Обмеження:Жадібний підхід працює лише для "канонічних" наборів монет, тобто таких, де він завжди гарантує оптимальний результат.
Наприклад, для набору [1, 5, 6, 9] і суми 12 жадібний алгоритм видасть 9 + 1 + 1 + 1 (4 монети), тоді як оптимальна відповідь — 6 + 6 (2 монети). 
Для нашого набору [50, 25, 10, 5, 2, 1] ця проблема не виникає.

2. Алгоритм динамічного програмування (find_min_coins)
Принцип роботи:Цей алгоритм гарантує знаходження мінімальної кількості монет для будь-якої суми. Він розв'язує задачу, розбиваючи її на менші підзадачі, і зберігає їхні розв'язки.
Це дозволяє уникнути повторних обчислень.
Ефективність та продуктивність:Часова складність: O(N⋅k), де N — сума, яку потрібно видати, а k — кількість номіналів монет.
Продуктивність: Для невеликих сум час виконання порівняний із жадібним алгоритмом. Однак, при значному зростанні суми (як у прикладі з 99999), час виконання експоненційно зростає,
оскільки алгоритм повинен перебрати всі можливі комбінації до заданої суми.

Порівняння та висновки

Критерій: Жадібний алгоритм/Динамічне програмування
Швидкість: Дуже швидкий/Повільніший для великих сум.
Складність: Простий в реалізації/Більш складний.
Оптимальність: Гарантує оптимум лише для "канонічних" наборів монет/Завжди гарантує оптимум

Висновок: Для системи касового апарату з набором монет [50, 25, 10, 5, 2, 1], жадібний алгоритм є оптимальним вибором.
Він не тільки забезпечує правильний результат, але й робить це з мінімальними обчислювальними витратами.
Це робить його ідеальним для практичного застосування в умовах, де потрібно видавати решту швидко.
Алгоритм динамічного програмування, хоча й є універсальнішим і може розв'язати будь-яку задачу про решту, для цього конкретного випадку буде значно повільнішим для великих сум.
Його варто використовувати, якщо номінали монет є нестандартними або змінюються, і ви потребуєте гарантованого оптимального рішення.
